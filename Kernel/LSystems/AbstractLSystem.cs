using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace Rabbit.Kernel.LSystems
{

    /**
     * The
essential difference between Chomsky grammars and L-systems lies in the method of applying productions. In Chomsky grammars productions
are applied sequentially, whereas in L-systems they are applied
in parallel and simultaneously replace all letters in a given word. This
difference reflects the biological motivation of L-systems.

LSystem is different from FormalGrammar because it do not differs terminal and nonTerminal symbols.

L-systems are strict subsets of languages.

L-Systems [1] have no concept of characters
that play different roles. Most rewriting systems
distinguish between variables and constants. Variables
have associated replacement strings; constants
do not and just stand for themselves.
In an L-system, if there is no rule for a character,
it is replaced by itself. In practical terms, it's a
constant.

http://en.wikipedia.org/wiki/L-system

The rules of the L-system grammar are applied iteratively starting from the initial state. As many rules as possible are applied simultaneously, per iteration; this is the distinguishing feature between an L-system and the formal language generated by a formal grammar. If the production rules were to be applied only one at a time, one would quite simply generate a language, rather than an L-system. Thus, L-systems are strict subsets of languages.

An L-system is context-free if each production rule refers only to an individual symbol and not to its neighbours. Context-free L-systems are thus specified by either a prefix grammar, or a regular grammar.

If a rule depends not only on a single symbol but also on its neighbours, it is termed a context-sensitive L-system.

If there is exactly one production for each symbol, then the L-system is said to be deterministic (a deterministic context-free L-system is popularly called a D0L-system). If there are several, and each is chosen with a certain probability during each iteration, then it is a stochastic L-system.

Using L-systems for generating graphical images requires that the symbols in the model refer to elements of a drawing on the computer screen. For example, the program Fractint uses turtle graphics (similar to those in the Logo programming language) to produce screen images. It interprets each constant in an L-system model as a turtle command.


In L-Systems Theory (4), Grammar is a set G = {V, S, w, P} where

    * V is a set (alphabet) of symbols containing elements (variables) to be replaced
    * S is a set of symbols containing fixed elements (constants)
    * w is a string (start, axiom or initiator) of symbols from V defining the system initial state
    * P is a set of re-write production rules defining the way variables are replaced with combinations of S and V
     * 
     */
    public abstract class AbstractLSystem:AbstractStringRewritingSystem
    {

        protected IList<Symbol> Alphabet;
        protected Word Axiom;
        protected IList<ProductionRule> ProductionRules;
        protected Word currentWord;

        //protected Dictionary<Char, IList<RewriteRule>> RulesLookUpMap;


        protected int CurrentDerivationIndex;
        protected IList<Word> words;//the words of the language

        public AbstractLSystem(IList<Symbol> Alphabet, Word Axiom) {
            //TODO: check whether the Axiom is contained in the Alphabet!(by definition)
            this.Alphabet = Alphabet;
            this.Axiom = Axiom;
            this.ProductionRules = new List<ProductionRule>();

            //init the list of words
            words = new List<Word>();
            this.CurrentDerivationIndex = 0;

            //start with the axiom as a first word in the language:
            AddWord(Axiom);

        }


        /**
         * Adds a rewrite rule to the set of rules used by the LSystem and validates it agains the policy of the LSystem implementation(Different implementation could not work with certain rules)
         */ 
        public virtual void AddRule(ProductionRule ProductionRule) {
            ProductionRules.Add(ProductionRule);
        }

        protected void AddWord(Word word)
        {
            currentWord = word;
            CurrentDerivationIndex++;
            words.Add(word);
        }

        /**
         * Generate the next word of the language based on the specified alphabet, axiom and rewrite rules.
         * Rewrite the CurrentWord
         * 
         *
        public override String Rewrite()
        {
            StringBuilder NextGeneration = new StringBuilder();
            for (int i = 0; i < CurrentString.Length; i++)
            {
                Char NextSymbol = CurrentString[i];
                ProductionRule RewriteRule = GetProductionRule(NextSymbol, i, CurrentString);
                if(RewriteRule!=null) 
                    NextGeneration.Append(RewriteRule.Rewrite(NextSymbol, i, CurrentString));
                else//if a rewrite rule is missing, rewrite the symbol with itself:
                    NextGeneration.Append(NextSymbol);
            }
            AddString(NextGeneration.ToString());

            return NextGeneration.ToString();
        }*/

        public override Word Rewrite()
        {
            Word nextWord = new Word();
            for (int i = 0; i < currentWord.GetSize(); i++)
            {
                Symbol predecessor = currentWord.SymbolAt(i);
                Word successor = null;
                foreach(ProductionRule productionRule in ProductionRules) {
                    successor = productionRule.Rewrite(predecessor, i, currentWord);
                    if (successor != null)//A Rule for that symbol is found!
                    {                        
                        nextWord.Append(successor);
                        break;
                    }
                }
                //there was no Rule which rewrote the predecessor symbol
                //As a matter of convention, if there is no rule
                // for a character, that character is left unchanged.
                if (successor == null)
                    nextWord.Append(predecessor);
                    
            }

            AddWord(nextWord);
            return nextWord;
        }

        /**
         * Generates a number of words at once
         * 
         */ 
        public void Rewrite(int derivationLength)
        {
            for (int i = 0; i < derivationLength; i++)
                Rewrite();
        }

        /**
         * @returns The RewriteRule associated with the specified Symbol(Predecessor)
         * 
         */
        protected abstract ProductionRule GetProductionRule(Symbol Symbol, int SymbolIndex, Word Word);

        public override Word GetSeed()
        {
            return GetAxiom();//.ToString();
        }
                                                                                                         

        /**
         * @returns The Axiom of the LSystem language
         */ 
        public Word GetAxiom()
        {
            return Axiom;
        }

        public override Word GetCurrentDerivation()
        {
            return currentWord;
        }

        public override IList<Word> GetLanguage()
        {
            return words;
        }

        public override int GetCurrentDerivationIndex()
        {
            return CurrentDerivationIndex;
        }

        public override String ToString()
        {
            StringBuilder LSystemDescription = new StringBuilder();
            LSystemDescription.AppendLine("LSystem")
                .Append("Axiom: ").AppendLine(Axiom.ToString())
                .AppendLine("Production Rules: ");

            //describe rules used
            foreach (ProductionRule rule in ProductionRules)
                LSystemDescription.AppendLine(rule.ToString());  
             
            //print out the generated language
            foreach (Word word in words)
                LSystemDescription.AppendLine(word.ToString());               

            return LSystemDescription.ToString();
        }

    }
}
